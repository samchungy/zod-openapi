# zod-openapi v5 ðŸ“š

This guide explains the key changes between zod-openapi v4 and v5.

## ðŸ”„ Differences from v4

### ðŸ› ï¸ Runtime Changes

âœ¨ **Removed runtime monkey-patching**

- `extendZodWithOpenApi()` and `import zod-openapi/extend` have been removed
- Zod v4 introduces a native `.meta()` method for adding OpenAPI metadata directly which makes `.openapi()` redundant

You can now declare `zod-openapi` as a dev dependency instead of a runtime dependency if you create schemas at build time.

ðŸ”„ **`openapi()` â†’ `meta()`**

```diff
- z.string().openapi({ ... })
+ z.string().meta({ ... })
```

This has been removed due to the new native `.meta()` method introduced in Zod v4

### ðŸ“Š Schema Generation Changes

ðŸ†• **OpenAPI version requirements**

- OpenAPI 3.1.0 is now the minimum required version
- Support for OpenAPI 3.1.1 has been added

ðŸš€ **Performance improvements**

- Internal schema generation replaced with Zod's native `toJSONSchema()` method
- This halves the size of the library and should deliver better performance

âœ¨ **Lazy schemas supported natively**

> Zod automatically creates lazy components, so you can use `z.lazy()` without any additional configuration. It is still recommended to provide an `id` for lazy schemas.

ðŸ”„ **`ref` â†’ `id`**

```diff
- .openapi({ ref: 'MySchema' })
+ .meta({ id: 'MySchema' })
```

Wherever you previously used `ref` to create components, has been replaced with `id` for consistency with Zod's syntax.

ðŸ“ **Input & Output Schema Generation**

Zod's native `toJSONSchema()` handles object schemas differently than our previous implementation:

- ðŸ“¥ **Input schemas:** Allow additional properties by default (no `additionalProperties` specified)
- ðŸ“¤ **Output schemas:** Strip extra properties (`additionalProperties: false`)

This better aligns with how Zod actually works, where input schemas are more permissive and output schemas are stricter and allows for [structured outputs](https://platform.openai.com/docs/guides/structured-outputs) for AI applications.

As a result, when a registered schema is referenced in both requests and responses, two separate component schemas are generated.

**How it works:**

1. Register a schema with an ID:

```ts
const schema = z
  .object({
    name: z.string(),
    age: z.number(),
  })
  .meta({
    id: 'Person',
  });
```

2. When used in both contexts, it automatically generates:

```ts
components: {
  schemas: {
    Person: {
      type: 'object',
      properties: {
        name: { type: 'string' },
        age: { type: 'number' },
      },
    },
    PersonOutput: {
      type: 'object',
      properties: {
        name: { type: 'string' },
        age: { type: 'number' },
      },
      additionalProperties: false,
    },
  },
}
```

**Customization options:**

- **Custom output name:** `.meta({ id: 'Person', outputId: 'CustomOutputName' })`
- **Global suffix:** Set `outputIdSuffix` in `CreateDocumentOptions` to change from default "Output"
- **Alternative:** Use `z.looseObject()` and `z.strictObject()` to create schemas instead of `z.object()` in order to have explicit control over input and output schemas.

> **âš ï¸ Limitation:** If your schema contains dynamically created lazy components, they won't be reused between input and output schemas.

âš¡ **Minor change:** Manual schema generation

> Previously, unsupported Zod schemas without a `type` field would throw an error. Now, any schema with fields will be accepted.
>
> You can modify this behavior with the new `allowEmptySchema` option (see [New Options](#-new-options) below).

âš¡ **Minor change:** `.extend()` behavior

- No longer creates an embedded `allOf` referenced schema
- This functionality would need to be contributed to the main Zod library if desired

### ðŸ”§ Zod OpenAPI Options

#### ðŸ” Renamed Options

ðŸ”„ **`refType` â†’ `unusedIO`**

#### âŒ Removed Options

âš™ï¸ **`effectType`**

> Transforms are not introspectable. `effectType` was introduced to attempt to address this and to try and keep the transform locked to the same type as the input schema.
> For transform operations, use Zod's native [`.overwrite()`](https://zod.dev/v4?id=overwrite) method, wrap your schema in a `.pipe()`, or declare a manual type.

ðŸ”„ **`unionOneOf`**
ðŸ”„ **`enforceDiscriminatedUnionComponents`**
ðŸ”„ **`defaultDateSchema`**

> These options are replaced by the new override system (see below)

#### ðŸ› ï¸ New Override System

**Direct property setting:**

This is native to Zod v4 and allows you to set properties directly on the schema.

```ts
z.date().meta({
  type: 'string',
  format: 'date-time',
});
```

> **Note:** Zod's native type representation takes precedence over the fields set in the `meta()` method.
> You can provide an `override` object or function to override this behavior.

**Simple example:**

```ts
z.string().meta({
  override: {
    type: number,
  },
});
```

**Advanced customization with functions:**

```ts
// Example: achieving unionOneOf behavior
z.union([z.string(), z.number()]).meta({
  override: ({ jsonSchema }) => {
    jsonSchema.oneOf = jsonSchema.anyOf;
    delete jsonSchema.anyOf;
  },
});
```

**Global overrides:**

```ts
import { createDocument } from 'zod-openapi';

createDocument(document, {
  override: ({ jsonSchema, zodSchema, io }) => {
    const def = zodSchema._zod.def;
    if (def.type === 'date' && io === 'output') {
      jsonSchema.type = 'string';
      jsonSchema.format = 'date-time';
    }
    if (def.type === 'union') {
      jsonSchema.oneOf = jsonSchema.anyOf;
      delete jsonSchema.anyOf;
    }
  },
});
```

> **Important:** Only an `override` function can be provided in `CreateDocumentOptions`. Schema-level `override` will always run after the global function.

#### âœ¨ New Options

ðŸ”„ **`cycles`, `reused`**

> These options are passed directly to Zod's `toJSONSchema()` method to control how cycles and reused schemas are handled.
>
> See [Zod's JSON Schema documentation](https://zod.dev/json-schema) for details.

ðŸ§© **`allowEmptySchema`**

> Controls when empty schemas can be created. This controls if zod-openapi will throw an error when an empty schema is encountered.
>
> - `true` â€” Allow for both input and output
> - `{ input: true, output: true }` â€” Allow for both input and output
> - `{ input: true }` â€” Allow for input only
> - `{ output: true }` â€” Allow for output only

#### ðŸ” Changed Options

ðŸ”„ **`refType` â†’ `unusedIO`**

> Renamed to better reflect its purpose: specifying how unused component schemas should be rendered.

#### ðŸ“‹ Create Schema Options

ðŸ”„ **`schemaType` â†’ `io`**

> Renamed to align with Zod's native terminology.

ðŸ”„ **`componentRefPath` â†’ `schemaComponentRefPath`**

> Renamed for clarity and consistency.

ðŸ”„ **`components` â†’ `schemaComponents`**

> Renamed for clarity and consistency.
